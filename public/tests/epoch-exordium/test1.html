<!DOCTYPE html>
<html>
	<head>
		<title>Initial drawing texture experiments</title>
		<style>
			body {
				margin: 0;
				padding: 0;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script src="/scripts/shared/three.min.js"></script>
		<script src="/scripts/shared/OrbitControls.js"></script>
		<script src="/scripts/shared/stats.min.js"></script>
		<script src="/scripts/shared/SimplexNoise.js"></script>
		<script type='text/javascript'>

		var camera, scene, renderer, texture, controls;
			var mesh;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer({alpha: true});
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000000 );
				camera.position.z = 4000;

				scene = new THREE.Scene();

				var geometry = new THREE.CubeGeometry( 1000000, 1000000, 1000000 );

				var texture_prefix = '/assets/game/textures/epoch-exordium_'
				var textures = [
					texture_prefix + 'right1.png',
					texture_prefix + 'left2.png',
					texture_prefix + 'top3.png',
					texture_prefix + 'bottom4.png',
					texture_prefix + 'front5.png',
					texture_prefix + 'back6.png'
				];

				var textureCube = THREE.ImageUtils.loadTextureCube( textures );
				textureCube.format = THREE.RGBFormat;

				var shader = THREE.ShaderLib[ "cube" ];
				shader.uniforms[ "tCube" ].value = textureCube;

				var material = new THREE.ShaderMaterial( {

					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: shader.uniforms,
					depthWrite: false,
					side: THREE.BackSide

				} );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				window.addEventListener( 'resize', onWindowResize, false );

			    controls = new THREE.OrbitControls( camera, renderer.domElement );

			    // Using AU (Astronomical Unit x 1000 + 1000 for sun's size) for distance, proportion to Earth for others
			    // Sun
			    scene.add(make_sphere({x: 0, y: 0, z: 0 }, 0xFDEE00, 1000 ));	
			    // Mercury
			    scene.add(make_sphere({x: 0, y: 0, z: 1387 }, 0x3D0C02, 3.82 ));	
			    // Venus
			    scene.add(make_sphere({x: 0, y: 0, z: 1723 }, 0x915C83, 9.49 ));	
			    // Earth
			    scene.add(make_sphere({x: 0, y: 0, z: 2000 }, 0x0033FF, 10 ));	
			    // Mars
			    scene.add(make_sphere({x: 0, y: 0, z: 2524 }, 0xA52A2A, 5.32 ));	
			    // Jupiter
			    scene.add(make_sphere({x: 0, y: 0, z: 6203 }, 0xB5A642, 111.9 ));	
			    // Saturn
			    scene.add(make_sphere({x: 0, y: 0, z: 10529 }, 0xE3DAC9, 92.6 ));	
			    // Uranus
				scene.add(make_sphere({x: 0, y: 0, z: 20190 }, 0x0070FF, 40.1 ));	
			    // Neptune
			    scene.add(make_sphere({x: 0, y: 0, z: 31060 }, 0x1974D2, 38.8 ));	
			    // Pluto
			    scene.add(make_sphere({x: 0, y: 0, z: 40530 }, 0x91A3B0, 1.8 ));	

			}

			function make_sphere(position, colour, radius) {
				// Sphere parameters: radius, segments along width, segments along height
				var sphere = new THREE.Mesh( new THREE.SphereGeometry( radius, 32, 16 ), new THREE.MeshBasicMaterial( { color: colour } ) );
			
				sphere.position.set(position.x, position.y, position.z);
				return sphere;
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update();

				renderer.render( scene, camera );

			}
 

		</script>
	</body>
</html>
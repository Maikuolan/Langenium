<!DOCTYPE html>
<html>
  <head>
    <title>Airship Academy | Wiki | Langenium
    </title>
    <link href="/vendor/Semantic-UI/dist/semantic.min.css" rel="stylesheet">
    <link href="/dist/styles.css" rel="stylesheet">
  </head>
  <body>
    <div id="fb-root"></div>
    <div class="container">
      <header class="row"><a class="logo" href="/" title="Langenium"><img src="/logo.png"></a>
        <nav>
          <ul>
            <li><a href="/about.html">About</a></li>
            <li><a href="/gallery">Gallery</a></li>
            <li><a href="/games">Games</a></li>
            <li><a href="/wiki">Wiki</a></li>
          </ul>
        </nav>
        <div class="fb-like" data-href="https://www.facebook.com/Langenium/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false"></div>
      </header>
      <div class="row">
        <h2>Airship Academy</h2><h2>About Airship Academy</h2>

<h3>Purpose</h3>

<p>A single player game designed to build up the cinematic and world building capabilities of the game engine. </p>
        <h3>Story Outline</h3><p>In 1931 a German engineer, Dr Bruno Lange, developed a photo cell using silver selenide in place of copper oxide. In 2043, a deep space radar telescope discovers a new element in the accretion disc of a black hole - langenium. Through studying it&#39;s activity, scientists believed that it could perfectly convert surrounding light into usable electric energy. With no hope of retrieving even a sample, humanity searched for other avenues.</p>

<p>in 2099, the human race is growing desperate for a new source of energy. An AI called WERP (Web Energy Research Protocol) is created in order to research and develop a new form of power generation and deployed into the world wide web. It is hoped that it will be able to come up with a solution using the sum of human knowledge.</p>

<p>One day,WERP determined that Earth was a sub-optimal homeworld due to knowing about the langenium research in the SETI archives.Using a gravity manipulating device, it was able to draw a solar flare close to Earth. The intention was to move humanity permanently and swiftly. WERP used the energy in the atmosphere to open a wormhole to Ibidan and left clues for the humans to find it.The solar flare released radiation that began to boil the planet. The humans eventually discovered the wormhole, sent a probe and couldn&#39;t believe their luck - an ocean planet with life waited on the other side.</p>

<p>They had an exit, but no way to move the entire human race in the time available. Aerial drones had been successful in reaching the other side and continuing on, so they boarded everyone onto planes. Military craft, private vehicles and commercial planes. This was all a part of WERP&#39;s plan.</p>

<p>A series of hydrogen bombs were detonated on both ends of the wormhole, increasing it&#39;s size, but landing a final blow to Earth. As soon as the radiation cleared and the upper atmosphere lit up, the humans went in.</p>

<p>On Ibidan, it was chaos. The velocity had propelled a few planes so hard they crashed. Most survived. With no way of knowing where to go, they flew in every direction with the fuel they had and hoped.</p>

<p>After the first few days on Ibidan, May Jung Lee&#39;s group gets split off from the military and VIP escorts due to wanting to help some stranded refugees. The scientists and refugees live together in peace.</p>

<p>Before coming to Ibidan Sir Francis Cross was the Minister for Defence of England. Today he is the lone survivor of his private jet. He is an injured, dying old man with little hope. His butler android, controlled by WERP, approaches him and offers to repair his ship and fly him back to the escort, however he must pledge himself to the android. The android threatens to stop his heart via his digital pace maker if he refuses anyway. Facing death, Sir Francis Cross complies.</p>

<p>Sir Francis Cross eventually regroups with the VIP escort and leads the construction of a new British empire, on orders from WERP.</p>

<p>Tor Dadak is Alazaar&#39;s best friend and a famous and respected combat pilot. He relies on body implants to live due to injuries from many wars. WERP can remotely see and hear everything Tor does, and communicates with him via consoles and computers around him. It threatens that it will take over his body and make him kill his wife and children if he does not do everything it wants.</p>

<p>WERP instructs Tor Dadak to build a nation called Al-Alazaar, much to Alazaar&#39;s dismay about using his name (he was humble). The people call themselves Za&#39;ar or Za&#39;aran.</p>

<p>On orders from WERP, Tor Dadak stages a revolution against the scientists for supposedly experimenting on children and banishes them to the ocean. May Jung Lee is allowed to stay but decides to leave to lead her team. That is the last time they see each other, she is pregnant.</p>

<p>It finally looks like peace might be possible. Prince Nicholas of Winthrom met Ana Jung-Lee at the Airship Academy and they are on their way to being wed.</p>

<p>It is the wedding day. Alazaar and May re-unite for the first time in 29 years and celebrate their love on a balcony at Winthrom castle. The wedding venue explodes killing the bride, groom and guests.</p>

<p>The world goes into a state of cold war over the incident. Sir Francis Scott pushes the belief that assassin&#39;s from Al-Alazaar were responsible. Likewise, Za&#39;ar people are convinced by Tor Dadak that members of the Winthrom elite were responsible. The Union press and citizens believe that neither side could be responsible as everyone stood to lose a lot from the events, however they have no proof and so choose to further recluse their domain. May begins to suspect that there is another presence on Ibidan and goes off to find it.</p>

<p>Alazaar does his own investigation into the insurgency at the wedding. It is revealed that both elite pirates and royal snipers were involved in the incident. This investigation leads him to Sir Francis Cross and then Tor Dadak, he kills them both.</p>

<p>In his last moments, Tor confesses that he has been receiving instructions from a Union AI. Alazaar believes him and passes this on but May doesn&#39;t believe him and continues her search for aliens. He goes in to where the parliament supposedly sits, and finds the room is empty. No one had been here in years.</p>

<p>He descends through the lower levels of The Union home base until eventually finding WERP&#39;s lair. WERP kills him.</p>

<p>Alazaar&#39;s death recalls May from her search. She investigates and confronts WERP. WERP explains that it had found the aliens she was searching for when they first arrived. The alien presence that has popped up here and there are way more advanced and could easily wipe us out if we were considered an overt threat. WERP created the factions in order to keep the human population smaller and well fortified and took advantage of the conflict as a means to research and develop new technologies. The humans could still create innovations that WERP couldn&#39;t imagine.... because it&#39;s a computer.</p>

<p>After hearing the story, Maydestroys WERP, however the entire Union faction requires it to be in place to function. Having lost her daughter and her love, she uploads herself to the central computer.</p>

<p>The world never recovered from the state of cold war. As an immortal AI advising the Union parliament, May sought to bring peace to the world however the revelations about WERP, Tor and Francis only lead to a further state of distrust between Al-Alazaar and Winthrom. The Union now plays the role of peacekeeper, using their vast technological superiority and trade agreements as a bargaining chip to prevent violence from escalating.</p>

<p>Aliens scouts have also begun attacking remote human outposts and it seems likely that they are systematically learning about humans before proceeding with a formulated plan to attack. No one is able to agree on how to handle the aliens.</p>
      </div>
    </div>
  </body>
  <script src="/vendor/jquery.min.js"></script>
  <script src="/vendor/wad/build/wad.min.js"></script>
  <script src="/vendor/Semantic-UI/dist/semantic.min.js"></script>
  <script src="/vendor/threejs/examples/js/libs/dat.gui.min.js"></script>
  <script src="/vendor/threejs/build/three.js"></script>
  <script src="/vendor/threejs/examples/js/libs/stats.min.js"></script>
  <script src="/vendor/threejs/examples/js/controls/OrbitControls.js"></script>
  <script src="/vendor/threejs/examples/js/loaders/ColladaLoader.js"></script>
  <script src="/vendor/threejs/examples/js/SimplexNoise.js"></script>
  <script src="/vendor/threejs/examples/js/GPUComputationRenderer.js"></script>
  <script src="/vendor/threejs/examples/js/Mirror.js"></script>
  <script src="/vendor/ocean/water-material.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/lib/live2d.min.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/framework/Live2DFramework.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/sample/sampleApp1/src/PlatformManager.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/sample/sampleApp1/src/LAppLive2DManager.js"></script>
  <script src="/vendor/Live2D_ThreeJS/Live2DRender.js"></script>
  <script id="logoWaterVertShader" type="x-shader/x-vertex">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform float time;

void main() 
{
    vNormal = normalize( normalMatrix * normal );

    vec4 mvPosition = modelMatrix * vec4( position, 1.0 );
    vViewPosition = cameraPosition - mvPosition.xyz;

    vTexCoord3D = .0111 * ( position.xyz + vec3( -time, -time, -time ) );

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
  </script>
  <script id="logoWaterFragShader" type="x-shader/x-fragment">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform sampler2D noiseTexture;
uniform float time;

float snoise ( vec3 coord, float scale, float time_factor ) {
    vec3 scaledCoord = coord * scale - (vNormal / time_factor + vec3(0.0, 0.0, -time / time_factor));

    vec2 uvTimeShift = vec2((scaledCoord.x + scaledCoord.z) / 2.0, scaledCoord.y) + vec2( -0.7, 1.5 ) * time / time_factor * 0.015;
    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
    vec2 uvNoiseTimeShift = vec2(scaledCoord.x, scaledCoord.y) + 0.5 * vec2( noiseGeneratorTimeShift.g, noiseGeneratorTimeShift.b );
    vec4 baseColor = texture2D( noiseTexture, uvNoiseTimeShift * vec2(4.0, 4.0) );

    return baseColor.b;
}

float heightMap( vec3 coord ) {
  float n = 0.0;

  n = 0.65 * abs(snoise(coord, 0.0625, 500. ));
  n += 0.5 * abs(snoise(coord, 0.125, 500. ));
  n += 0.125 * abs(snoise(coord, 5., 50. ));
  n += 0.125 * abs(snoise(coord, 100., 150. ));
  n *= .75;

  return n;
}

float limitColor( float min, float max, float channel) {
  if (channel < min) {
    channel = min;
  }
  if (channel > max) {
    channel = max;
  }
  return channel;
}

vec4 colorFilter(float n) {

  vec4 color = vec4( vec3( 0.01 * n, 0.25 * n, .95 * n )  , 1.0 );

  color.r = limitColor(0.0, 0.05, color.r);
  color.g = limitColor(0.015, 0.25, color.g);
  color.b = limitColor (0.025, 0.75, color.b);

  return color;
}

void main() 
{
    float n = heightMap( vTexCoord3D );

    vec4 texColor = colorFilter( n );

    // color
    gl_FragColor = texColor;
  
  // normal

  const float e = 0.011;

  float nx = heightMap( vTexCoord3D + vec3( e, 0.0, 0.0 ) );
  float ny = heightMap( vTexCoord3D + vec3( 0.0, e, 0.0 ) );
  float nz = heightMap( vTexCoord3D + vec3( 0.0, 0.0, e ) );

  vec3 normal = normalize( vNormal + 0.0285 * vec3( n - nx, n - ny, n - nz ) / e );

  // diffuse light

  vec3 vLightWeighting = vec3( -0.01 );

  vec4 lDirection = viewMatrix * vec4( normalize( vec3( -0.5, -2.0, 1.5 ) ), 0.0 );
  float directionalLightWeighting = dot( normal, normalize( lDirection.xyz ) ) * 0.35 + 0.75;
  vLightWeighting += vec3( 1.0 ) * directionalLightWeighting;

  // specular light

  vec3 dirHalfVector = normalize( lDirection.xyz + normalize( vViewPosition ) );

  float dirDotNormalHalf = dot( normal, dirHalfVector );

  float dirSpecularWeight = 0.0;
  if ( dirDotNormalHalf >= 0.0 )
    dirSpecularWeight = ( 1.0 - n ) * pow( dirDotNormalHalf, 16.0 );

  vLightWeighting += vec3( 0.5, 0.5, 1.5 ) * dirSpecularWeight * n * 15.0;

  gl_FragColor *= vec4( vLightWeighting, 1.0 ); //
}
  </script>
  <script id="logoMetalVertShader" type="x-shader/x-vertex">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform float time;

void main() 
{
    vNormal = normalize( normalMatrix * normal );

    vec4 mvPosition = modelMatrix * vec4( position, 1.0 );
    vViewPosition = cameraPosition - mvPosition.xyz;

    vTexCoord3D = -11.1111 * ( position.xyz + vec3( -time, -time , -time ) );

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
  </script>
  <script id="logoMetalFragShader" type="x-shader/x-fragment">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform sampler2D noiseTexture;
uniform float time;

float snoise ( vec3 coord, float scale, float time_factor ) {
    vec3 scaledCoord = coord * scale - (vNormal / time_factor + vec3(0., 0.0, -time / time_factor));

    vec2 uvTimeShift = vec2((scaledCoord.x + scaledCoord.z) / 2.0, scaledCoord.y) + vec2( -0.7, 1.5 ) * time / time_factor * 0.015;
    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
    vec2 uvNoiseTimeShift = vec2(scaledCoord.x, scaledCoord.z) + 0.5 * vec2( noiseGeneratorTimeShift.g, noiseGeneratorTimeShift.b );
    vec4 baseColor = texture2D( noiseTexture, uvNoiseTimeShift * vec2(4.0, 4.0) );

    return baseColor.b;
}

float heightMap( vec3 coord ) {
  float n = 0.0125 * abs(snoise(coord, 0.0625, -15000. ));
  n += 0.1125 * abs(snoise(coord, 5., -1500. ));
  n += 0.125 * abs(snoise(coord, 5., -750. ));
  n += 0.25 * abs(snoise(coord, 0.125, -500. ));
  return n;
}

float limitColor( float min, float max, float channel) {
  if (channel < min) {
    channel = min;
  }
  if (channel > max) {
    channel = max;
  }
  return channel;
}

vec4 colorFilter(float n) {

  vec4 color = vec4( vec3( 0.25 *n, 0.25 * n, 0.25 * n )  , 1.0 );

  color.r = limitColor(0.1, 0.9, color.r);
  color.g = limitColor(0.1, 0.9, color.g);
  color.b = limitColor (0.1, 0.9, color.b);

  return color;
}

void main() 
{
  float n = heightMap( vTexCoord3D );

  vec4 texColor = colorFilter( n );

  // color
  gl_FragColor = texColor;
  
  // normal
  const float e = .01;

  float nz = heightMap( vTexCoord3D + vec3( e, 0.0, 0.0 ) );
  float ny = heightMap( vTexCoord3D + vec3( 0.0, e, 0.0 ) );
  float nx = heightMap( vTexCoord3D + vec3( 0.0, 0.0, e ) );

  vec3 normal = normalize( vNormal + .085 * vec3( n - nx, n - ny, n - nz ) / e );

  // diffuse light

  vec3 vLightWeighting = vec3( -0.111 );

  vec4 lDirection = viewMatrix * vec4( normalize( vec3( 0.0, -1.0, 1.5 ) ), 0.0 );
  float directionalLightWeighting = dot( normal, normalize( lDirection.xyz ) ) * 0.35 + 0.65;
  vLightWeighting += vec3( 1.0 ) * directionalLightWeighting;

  // specular light

  vec3 dirHalfVector = normalize( lDirection.xyz + normalize( vViewPosition ) );

  float dirDotNormalHalf = dot( normal, dirHalfVector );

  float dirSpecularWeight = 0.0;
  if ( dirDotNormalHalf >= 0.0 )
      dirSpecularWeight = ( 1.0 - n ) * pow( dirDotNormalHalf, 6.0 );

  vLightWeighting += vec3( 0.75, 0.75, 0.75 ) * dirSpecularWeight * n * 11.0;

  gl_FragColor *= vec4( vLightWeighting, 1.0 ); //
}
  </script>
  <script id="heightmapFragmentShader" type="x-shader/x-fragment">#include <common>
uniform vec2 mousePos;
uniform float mouseSize;
uniform float viscosityConstant;
#define deltaTime ( 1.0 / 60.0 )
#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )
void main() {
  vec2 cellSize = 1.0 / resolution.xy;
  vec2 uv = gl_FragCoord.xy * cellSize;
  // heightmapValue.x == height
  // heightmapValue.y == velocity
  // heightmapValue.z, heightmapValue.w not used
  vec4 heightmapValue = texture2D( heightmap, uv );
  // Get neighbours
  vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
  vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
  vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
  vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );
  float sump = north.x + south.x + east.x + west.x - 4.0 * heightmapValue.x;
  float accel = sump * GRAVITY_CONSTANT;
  // Dynamics
  heightmapValue.y += accel;
  heightmapValue.x += heightmapValue.y * deltaTime;
  // Viscosity
  heightmapValue.x += sump * viscosityConstant;
  // Mouse influence
  float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
  heightmapValue.x += cos( mousePhase ) + 1.0;
  gl_FragColor = heightmapValue;
}
  </script>
  <script id="smoothFragmentShader" type="x-shader/x-fragment">uniform sampler2D texture;
void main() {
    vec2 cellSize = 1.0 / resolution.xy;
    vec2 uv = gl_FragCoord.xy * cellSize;
    // Computes the mean of texel and 4 neighbours
    vec4 textureValue = texture2D( texture, uv );
    textureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );
    textureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );
    textureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );
    textureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );
    textureValue /= 5.0;
    gl_FragColor = textureValue;
}
  </script>
  <script id="waterVertexShader" type="x-shader/x-vertex">uniform sampler2D heightmap;
#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
  varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
  vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );
  #include <uv_vertex>
  #include <uv2_vertex>
  #include <color_vertex>
  // # include <beginnormal_vertex>
  // Compute normal from heightmap
  vec3 objectNormal = vec3(
    ( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
    ( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
    1.0 );
  //<beginnormal_vertex>
  #include <morphnormal_vertex>
  #include <skinbase_vertex>
  #include <skinnormal_vertex>
  #include <defaultnormal_vertex>
#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
  vNormal = normalize( transformedNormal );
#endif
  //# include <begin_vertex>
  float heightValue = texture2D( heightmap, uv ).x;
  vec3 transformed = vec3( position.x, position.y, heightValue );
  //<begin_vertex>
  #include <displacementmap_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>
  vViewPosition = - mvPosition.xyz;
  #include <worldpos_vertex>
  #include <envmap_vertex>
  #include <shadowmap_vertex>
}
  </script>
  <script src="/dist/L.js"></script>
  <script src="/dist/logo.js"></script>
  <script>
    // Facebook Like Button.
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.8";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
     
    // Google Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
     
    ga('create', 'UA-37159175-1', 'auto');
    ga('send', 'pageview');
  </script>
</html>
<!DOCTYPE html>
<html>
  <head>
    <title>Gameplay | Epoch Exordium | Wiki | Langenium
    </title>
    <link href="/vendor/Semantic-UI/dist/semantic.min.css" rel="stylesheet">
    <link href="/dist/styles.css" rel="stylesheet">
    <link href="/dist/content.css" rel="stylesheet">
  </head>
  <body>
    <div id="fb-root"></div>
    <div class="container">
      <header class="row"><a class="logo" href="/" title="Langenium"><img src="/logo.png"></a>
        <nav>
          <ul>
            <li><a href="/about.html">About</a></li>
            <li><a href="/gallery">Gallery</a></li>
            <li><a href="/games">Games</a></li>
            <li><a href="/wiki">Wiki</a></li>
          </ul>
        </nav>
        <div class="fb-like" data-href="https://www.facebook.com/Langenium/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false"></div>
      </header>
      <div id="content">
        <div class="row">
          <h2>Epoch Exordium Gameplay</h2><h2>Gameplay</h2>

<h3>Objective Ideas</h3>

<ul><li>Build a new station<ul><li>Every station created spawns a new unique component, which then becomes required for every new station built</li><li>later down in the game, players will be able to <ul><li>&#39;place&#39; their station in the available locations<ul><li>They will need to choose what to orbit and use a combination of Lagrange calculations to determine the position</li></ul></li><li>Go to various stations to gather certain component blueprints</li><li>Go to various stations to organize the harvest/production of raw materials and delivery to that location</li><li>Recruit drones in the network to come and build the station (drones migrate between the asteroid belt for harvest, stations to repair and any position facing the sun to recharge)</li></ul></li><li>the incentive is<ul><li>the completion of the construction of a station is the endgame</li><li>player&#39;s brain is harvested to be used as the on-station AI for what they built</li><li>brain memories contain &quot;so much more&quot; than the instruments of a computer can measure in the same timespan - each human brain is an ideal component for expanding individual nodes of the network. he too has an artificial organic brain and understands well that the human ego has a limited view on the memories in the brain, and that he&#39;d be able to easily parse through their experiences and instill a superior personality based on himself. This eventually turns out to have backfired when players in Langenium MMO start hearing from the harvested brain people via random inheritance, lost+found datalogs, etc. Some of the explorers were able to fight back against the WERP persona within them and retain their individuality... while being a space station.</li><li>WERP is using the generations of clones derived from the genetic pool of the original team to &#39;breed&#39; the perfect cycle of explorers for his task. The number of player deaths is the number of times &quot;this explorer&quot; has been cloned for use by the system.</li><li>WERP entices the explorers by making them think that they are cracking some kind of elusive mystery, when they are simply gathering the data WERP needs in their heads by witnessing key events at each station and performing certain tasks</li></ul></li></ul></li><li>Exploring the network<ul><li>Discover hidden information about the backstory from datalogs left behind by other explorers and news articles from Earth - accessed by a console</li><li>Discover the GARDEN OF BABYLON IN SPACE, which you will need to maintain your food/water supply (you&#39;re basically a hitchhiker on this network, with no equipment but your PDA)</li><li>Sleep in bunks or in your sleeping bag to recharge your sleep levels - warnings will come up saying you need to sleep, but you can ignore them. if SLEEP depletes you black out and an overlay says &quot;You went insane, stripped naked and took a stroll out the airlock. Try sleeping next time, K?&quot;. You respawn at the starting point</li><li>Dodge asteroids, space junk while traversing a guided obstacle course<ul><li>Dodge rocks, ice and garbage from the drone construction</li><li>Manouvre the shuttle into certain positions for &#39;bonuses&#39; of some kind<ul><li>Explanation could be for surveying purposes or getting slight speed bonuses</li></ul></li><li>Impact doesn&#39;t stop you, but it slows you down<ul><li>Unmanageable deceleration results in being lost in space and dying - you respawn at the first station if you die (as explained by the end-game, you are actually coming back as a different person)</li></ul></li></ul></li><li>Eventually, players will discover that they can build new stations, and that the system is waiting for &#39;human input&#39; in order to proceed with the next stage of construction</li></ul></li><li>Completing missions<ul><li>Unlock missions and activities by travelling to stations with different capabilities</li><li>Missions from Earth<ul><li>Explore every station</li><li>Determine the purpose of the network</li><li>Make contact with WERP</li></ul></li><li>Missions from exploration (explained to be the player&#39;s own curiosity... maybe stick it in some kind of traveller&#39;s log as a self assigned goal?)<ul><li>Item retrieval/delivery - certain devices need to be delivered from point A to B and operated by a human<ul><li>&quot;Find a plot device&quot; that is mentioned </li><li>&quot;Take the plot device to station X&quot; that is mentioned </li><li>&quot;Place the plot device in the theatric device&quot; that then does some SFX show</li></ul></li><li>Raw material sourcing<ul><li>Check survey data and deploy drones to new areas for harvesting materials, you can send instructions to any drone but it&#39;ll create problems for your supply line</li><li>The stations will direct the players to gather these raw materials, as part of conversations with onboard AI</li></ul></li><li>Produce exordium for Earth - datalogs explain that this is the point of this entire setup, to create clean energy for Earth<ul><li>Players discover that the space stations are for building a new clean source that can only be made in space - Exordium</li><li>Players pick an area with available drones and organize supply routes of resources to their current location</li><li>Players set a &#39;home station&#39; and park there. Their aim is to get the supply line feeding to this station. If players change stations, any materials collected have to either be transported manually via capsule (per station) or ejected into space</li><li>Each station is capable of producing exordium, but the device needs all the right materials. Exordium is shipping back to Earth via the back supply line.</li><li>Every station producing exordium unlocks a previously inaccessible area (due to air shortage/low power)</li><li>These inaccessible areas are key to discovering the secret to building new stations - whether it is retrieving an item like a blueprint or performing a weird arbitrary science experiment</li></ul></li></ul></li></ul></li></ul>
        </div>
      </div>
    </div>
  </body>
  <script src="/vendor/jquery.min.js"></script>
  <script src="/vendor/wad/build/wad.min.js"></script>
  <script src="/vendor/Semantic-UI/dist/semantic.min.js"></script>
  <script src="/vendor/threejs/examples/js/libs/dat.gui.min.js"></script>
  <script src="/vendor/threejs/build/three.js"></script>
  <script src="/vendor/threejs/examples/js/libs/stats.min.js"></script>
  <script src="/vendor/threejs/examples/js/controls/OrbitControls.js"></script>
  <script src="/vendor/threejs/examples/js/loaders/ColladaLoader.js"></script>
  <script src="/vendor/threejs/examples/js/SimplexNoise.js"></script>
  <script src="/vendor/threejs/examples/js/GPUComputationRenderer.js"></script>
  <script src="/vendor/threejs/examples/js/Mirror.js"></script>
  <script src="/vendor/ocean/water-material.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/lib/live2d.min.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/framework/Live2DFramework.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/sample/sampleApp1/src/PlatformManager.js"></script>
  <script src="/vendor/Live2D-WebGL-SDK/sample/sampleApp1/src/LAppLive2DManager.js"></script>
  <script src="/vendor/Live2D_ThreeJS/Live2DRender.js"></script>
  <script id="logoWaterVertShader" type="x-shader/x-vertex">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform float time;

void main() 
{
    vNormal = normalize( normalMatrix * normal );

    vec4 mvPosition = modelMatrix * vec4( position, 1.0 );
    vViewPosition = cameraPosition - mvPosition.xyz;

    vTexCoord3D = .0111 * ( position.xyz + vec3( -time, -time, -time ) );

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
  </script>
  <script id="logoWaterFragShader" type="x-shader/x-fragment">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform sampler2D noiseTexture;
uniform float time;

float snoise ( vec3 coord, float scale, float time_factor ) {
    vec3 scaledCoord = coord * scale - (vNormal / time_factor + vec3(0.0, 0.0, -time / time_factor));

    vec2 uvTimeShift = vec2((scaledCoord.x + scaledCoord.z) / 2.0, scaledCoord.y) + vec2( -0.7, 1.5 ) * time / time_factor * 0.015;
    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
    vec2 uvNoiseTimeShift = vec2(scaledCoord.x, scaledCoord.y) + 0.5 * vec2( noiseGeneratorTimeShift.g, noiseGeneratorTimeShift.b );
    vec4 baseColor = texture2D( noiseTexture, uvNoiseTimeShift * vec2(4.0, 4.0) );

    return baseColor.b;
}

float heightMap( vec3 coord ) {
  float n = 0.0;

  n = 0.65 * abs(snoise(coord, 0.0625, 500. ));
  n += 0.5 * abs(snoise(coord, 0.125, 500. ));
  n += 0.125 * abs(snoise(coord, 5., 50. ));
  n += 0.125 * abs(snoise(coord, 100., 150. ));
  n *= .75;

  return n;
}

float limitColor( float min, float max, float channel) {
  if (channel < min) {
    channel = min;
  }
  if (channel > max) {
    channel = max;
  }
  return channel;
}

vec4 colorFilter(float n) {

  vec4 color = vec4( vec3( 0.01 * n, 0.25 * n, .95 * n )  , 1.0 );

  color.r = limitColor(0.0, 0.05, color.r);
  color.g = limitColor(0.015, 0.25, color.g);
  color.b = limitColor (0.025, 0.75, color.b);

  return color;
}

void main() 
{
    float n = heightMap( vTexCoord3D );

    vec4 texColor = colorFilter( n );

    // color
    gl_FragColor = texColor;
  
  // normal

  const float e = 0.011;

  float nx = heightMap( vTexCoord3D + vec3( e, 0.0, 0.0 ) );
  float ny = heightMap( vTexCoord3D + vec3( 0.0, e, 0.0 ) );
  float nz = heightMap( vTexCoord3D + vec3( 0.0, 0.0, e ) );

  vec3 normal = normalize( vNormal + 0.0285 * vec3( n - nx, n - ny, n - nz ) / e );

  // diffuse light

  vec3 vLightWeighting = vec3( -0.01 );

  vec4 lDirection = viewMatrix * vec4( normalize( vec3( -0.5, -2.0, 1.5 ) ), 0.0 );
  float directionalLightWeighting = dot( normal, normalize( lDirection.xyz ) ) * 0.35 + 0.75;
  vLightWeighting += vec3( 1.0 ) * directionalLightWeighting;

  // specular light

  vec3 dirHalfVector = normalize( lDirection.xyz + normalize( vViewPosition ) );

  float dirDotNormalHalf = dot( normal, dirHalfVector );

  float dirSpecularWeight = 0.0;
  if ( dirDotNormalHalf >= 0.0 )
    dirSpecularWeight = ( 1.0 - n ) * pow( dirDotNormalHalf, 16.0 );

  vLightWeighting += vec3( 0.5, 0.5, 1.5 ) * dirSpecularWeight * n * 15.0;

  gl_FragColor *= vec4( vLightWeighting, 1.0 ); //
}
  </script>
  <script id="logoMetalVertShader" type="x-shader/x-vertex">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform float time;

void main() 
{
    vNormal = normalize( normalMatrix * normal );

    vec4 mvPosition = modelMatrix * vec4( position, 1.0 );
    vViewPosition = cameraPosition - mvPosition.xyz;

    vTexCoord3D = -11.1111 * ( position.xyz + vec3( -time, -time , -time ) );

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
  </script>
  <script id="logoMetalFragShader" type="x-shader/x-fragment">varying vec3 vNormal;
varying vec3 vTexCoord3D;
varying vec3 vViewPosition;

uniform sampler2D noiseTexture;
uniform float time;

float snoise ( vec3 coord, float scale, float time_factor ) {
    vec3 scaledCoord = coord * scale - (vNormal / time_factor + vec3(0., 0.0, -time / time_factor));

    vec2 uvTimeShift = vec2((scaledCoord.x + scaledCoord.z) / 2.0, scaledCoord.y) + vec2( -0.7, 1.5 ) * time / time_factor * 0.015;
    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
    vec2 uvNoiseTimeShift = vec2(scaledCoord.x, scaledCoord.z) + 0.5 * vec2( noiseGeneratorTimeShift.g, noiseGeneratorTimeShift.b );
    vec4 baseColor = texture2D( noiseTexture, uvNoiseTimeShift * vec2(4.0, 4.0) );

    return baseColor.b;
}

float heightMap( vec3 coord ) {
  float n = 0.0125 * abs(snoise(coord, 0.0625, -15000. ));
  n += 0.1125 * abs(snoise(coord, 5., -1500. ));
  n += 0.125 * abs(snoise(coord, 5., -750. ));
  n += 0.25 * abs(snoise(coord, 0.125, -500. ));
  return n;
}

float limitColor( float min, float max, float channel) {
  if (channel < min) {
    channel = min;
  }
  if (channel > max) {
    channel = max;
  }
  return channel;
}

vec4 colorFilter(float n) {

  vec4 color = vec4( vec3( 0.25 *n, 0.25 * n, 0.25 * n )  , 1.0 );

  color.r = limitColor(0.1, 0.9, color.r);
  color.g = limitColor(0.1, 0.9, color.g);
  color.b = limitColor (0.1, 0.9, color.b);

  return color;
}

void main() 
{
  float n = heightMap( vTexCoord3D );

  vec4 texColor = colorFilter( n );

  // color
  gl_FragColor = texColor;
  
  // normal
  const float e = .01;

  float nz = heightMap( vTexCoord3D + vec3( e, 0.0, 0.0 ) );
  float ny = heightMap( vTexCoord3D + vec3( 0.0, e, 0.0 ) );
  float nx = heightMap( vTexCoord3D + vec3( 0.0, 0.0, e ) );

  vec3 normal = normalize( vNormal + .085 * vec3( n - nx, n - ny, n - nz ) / e );

  // diffuse light

  vec3 vLightWeighting = vec3( -0.111 );

  vec4 lDirection = viewMatrix * vec4( normalize( vec3( 0.0, -1.0, 1.5 ) ), 0.0 );
  float directionalLightWeighting = dot( normal, normalize( lDirection.xyz ) ) * 0.35 + 0.65;
  vLightWeighting += vec3( 1.0 ) * directionalLightWeighting;

  // specular light

  vec3 dirHalfVector = normalize( lDirection.xyz + normalize( vViewPosition ) );

  float dirDotNormalHalf = dot( normal, dirHalfVector );

  float dirSpecularWeight = 0.0;
  if ( dirDotNormalHalf >= 0.0 )
      dirSpecularWeight = ( 1.0 - n ) * pow( dirDotNormalHalf, 6.0 );

  vLightWeighting += vec3( 0.75, 0.75, 0.75 ) * dirSpecularWeight * n * 11.0;

  gl_FragColor *= vec4( vLightWeighting, 1.0 ); //
}
  </script>
  <script id="heightmapFragmentShader" type="x-shader/x-fragment">#include <common>
uniform vec2 mousePos;
uniform float mouseSize;
uniform float viscosityConstant;
#define deltaTime ( 1.0 / 60.0 )
#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )
void main() {
  vec2 cellSize = 1.0 / resolution.xy;
  vec2 uv = gl_FragCoord.xy * cellSize;
  // heightmapValue.x == height
  // heightmapValue.y == velocity
  // heightmapValue.z, heightmapValue.w not used
  vec4 heightmapValue = texture2D( heightmap, uv );
  // Get neighbours
  vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
  vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
  vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
  vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );
  float sump = north.x + south.x + east.x + west.x - 4.0 * heightmapValue.x;
  float accel = sump * GRAVITY_CONSTANT;
  // Dynamics
  heightmapValue.y += accel;
  heightmapValue.x += heightmapValue.y * deltaTime;
  // Viscosity
  heightmapValue.x += sump * viscosityConstant;
  // Mouse influence
  float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
  heightmapValue.x += cos( mousePhase ) + 1.0;
  gl_FragColor = heightmapValue;
}
  </script>
  <script id="smoothFragmentShader" type="x-shader/x-fragment">uniform sampler2D texture;
void main() {
    vec2 cellSize = 1.0 / resolution.xy;
    vec2 uv = gl_FragCoord.xy * cellSize;
    // Computes the mean of texel and 4 neighbours
    vec4 textureValue = texture2D( texture, uv );
    textureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );
    textureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );
    textureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );
    textureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );
    textureValue /= 5.0;
    gl_FragColor = textureValue;
}
  </script>
  <script id="waterVertexShader" type="x-shader/x-vertex">uniform sampler2D heightmap;
#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
  varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
  vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );
  #include <uv_vertex>
  #include <uv2_vertex>
  #include <color_vertex>
  // # include <beginnormal_vertex>
  // Compute normal from heightmap
  vec3 objectNormal = vec3(
    ( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
    ( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
    1.0 );
  //<beginnormal_vertex>
  #include <morphnormal_vertex>
  #include <skinbase_vertex>
  #include <skinnormal_vertex>
  #include <defaultnormal_vertex>
#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
  vNormal = normalize( transformedNormal );
#endif
  //# include <begin_vertex>
  float heightValue = texture2D( heightmap, uv ).x;
  vec3 transformed = vec3( position.x, position.y, heightValue );
  //<begin_vertex>
  #include <displacementmap_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>
  vViewPosition = - mvPosition.xyz;
  #include <worldpos_vertex>
  #include <envmap_vertex>
  #include <shadowmap_vertex>
}
  </script>
  <script src="/dist/L.js"></script>
  <script src="/dist/logo.js"></script>
  <script>
    // Facebook Like Button.
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.8";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
     
    // Google Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
     
    ga('create', 'UA-37159175-1', 'auto');
    ga('send', 'pageview');
  </script>
</html>